<!DOCTYPE html>

<html>
    <head>
        <meta charset="utf-8"/>
        <title> Home |  Caleb Stanford</title>
        <link rel="stylesheet" href="/style.css" />
        <meta name="description" content="Personal website and blog"/>
        <meta name="author" content="Caleb Stanford"/>
        <link rel="author" href="humans.txt"/>

        <!-- Facebook comment plugin. Two options for moderation. -->
        <meta property="fb:app_id" content="340544043003976" />
        <!-- <meta property="fb:admins" content="10210277106142031"/> -->

        <!-- <link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/feed.xml" /> -->

        <link rel="stylesheet" href="/resources/fontello/css/fontello.css">
        <link rel="stylesheet" href="/resources/fontello/css/animation.css">
        <!--[if IE 7]><link rel="stylesheet" href="/resources/fontello/css/fontello-ie7.css"><![endif]-->

        <!-- Google Analytics -->
        
        <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-93362615-1', 'auto');
  ga('send', 'pageview');

</script>

<!-- Replaced tracking code: UA-93362615-1, and placed in _config.yml.
 	 See https://desiredpersona.com/google-analytics-jekyll/. -->

        

    </head>

    <!-- MATHJAX! -->
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

    <body>
        <header>
            <h1><a href="/">Caleb Stanford</a></h1>
            <!-- <h2>New posts always eventually.</h2> -->
            <hr />
        </header>

            <nav>

            <h3>Site</h3>
            <ul>
                <li><i class="icon-home"></i> <a href="/">Home</a></li>
                <li><i class="icon-user"></i> <a href="/about">About</a></li>
                <li><i class="icon-popup"></i> <a href="/research">Research</a></li>
                <li><i class="icon-star"></i> <a href="/projects">Projects</a></li>
                <li><i class="icon-trash"></i> <a href="/misc">Miscellaneous</a></li>
            </ul>
            
            <h3>Posts</h3>
            <ul>
                <li><i class="icon-tag"></i> <a href="/tags">By tag</a></li>
                <li><i class="icon-list"></i> <a href="/archive">By date</a></li>
                <!-- Uncomment if I decide I want rss. -->
                <!-- <li><i class="icon-rss"></i>    <a href="/feed.xml">RSS Feed</a></li> -->
            </ul>
            <!-- <h3>Blog links</h3>
            <ul>
                <li><i class="icon-list"></i>     <a href="/archive">Archive</a></li>
                <li><i class="icon-list"></i>     <a href="/archive">Archive</a></li>
            </ul> -->


            <!-- <h3>Links</h3>
            <ul>
                <li><i class="icon-link"></i>   <a href="#">Link 1</a></li>
                <li><i class="icon-link"></i>   <a href="#">Link 2</a></li>
                <li><i class="icon-link"></i>   <a href="#">Link 3</a></li>
            </ul> -->
        </nav>

        <main>

            <!-- Show last n posts here -->
<!-- Using paginator! -->
<!-- n is the 'paginate' value in _config.yml -->

	<article>

        <header>
            <h2><a href="/2019/10/01/dominion-tournament-round2/">Dominion Online tournament 2019 (Round 2)</a></h2>
            <span class="date"><i class="icon-clock"></i><time datetime="2019-10-01">Oct 01, 2019</time></span><br/>
            <!-- <span class="category"><i class="icon-tag"></i> </span><br/> -->
            <!-- <span class="author"><i class="icon-user"></i> Caleb Stanford</span><br/> --> <!-- Uncomment if I ever decide I want categories -->
			<!-- Tags -->
			<span class="tags"><i class="icon-tag"></i>
				
				<a href="/tags/games">games</a> <!-- no # in the link for now -->
				<!-- <a href="tags/#games">games</a> --> <!-- getting this to work would be most ideal -->
				
				<a href="/tags/dominion">dominion</a> <!-- no # in the link for now -->
				<!-- <a href="tags/#dominion">dominion</a> --> <!-- getting this to work would be most ideal -->
				
			</span>
			<!-- Facebook comments count. -->
			<!-- Being stupid. Disabling for now. -->
			<!-- <div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.8&appId=340544043003976";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

			<span class="comments"><i class="icon-comment"></i>  Comments:
		 	<a href="http://cdstanford.github.io/2019/10/01/dominion-tournament-round2/"><span class="fb-comments-count" data-href=http://cdstanford.github.io/2019/10/01/dominion-tournament-round2/>0</span></a></span> -->

        </header>

		<div class="entry"><p>I’m participating in the <a href="https://dominion.games">Dominion Online</a> tournament again this year. I didn’t post about Round 1 this year, but here are <a href="/2018/09/18/dominion-tournament-round1/">Round 1</a> and <a href="/2018/09/29/dominion-tournament-round2/">Round 2</a> from last year.</p>

<p>For each of the 4 games, I provide the kingdom, and the puzzle is to guess the most valuable cards on the board (before looking at the spoiler), i.e. which cards are most important to the best strategy. For reference, a list of all Dominion cards can be found <a href="http://wiki.dominionstrategy.com/index.php/List_of_cards">here</a>.</p>

<p>These boards were really cool! At least two of them involved strategies I had never seen before, and none of them involved a totally standard or obvious strategy.</p>

<h3 id="game-1">Game 1</h3>

<p><img src="/img/2019/dominion-tournament-round2/kingdom1.png" alt="Kingdom 1" style="width: 80%" title="Kingdom 1" /></p>

<details>
<summary>Spoiler:</summary>

<p>Most valuable card(s): City Quarter and Leprechaun. Honorable Mention: Pixie.</p>

<p>This board has everything we need to build an engine, with only one problem: gains. City Quarter on its own is plenty of draw and actions, and it's even better because we can set up the start of our turn with Dungeon. But to build the engine, and to make effective use of it at the end, we're going to need more than one gain per turn. That's where Leprechaun and Pixie come in.</p>

<p>Leprechaun is not a good buy early on (Gold clogs up our deck and makes it difficult to get the engine going), but it becomes of critical importance once we can activate it every turn. (Sadly, there's no way to activate it twice.) Wish can be used to pick up engine components or Duchies -- against an opponent who is only buying one card per turn, that is very strong.</p>

<p>Pixie is also really good here. Because gains are limited, we wait until we hit Earth's Gift, Forest's Gift, or Swamp's Gift. In my deck, I had about $14 in my deck after Leprechaun had activated for a few turns -- this is overkill because only $8 of it can be used. That means that if we get Forest's Gift once, we can double province, which is likely game-deciding.</p>

<p>The alternative to all of this is to play Dungeon Money, perhaps with a Leprechaun or a Tormentor and some Pixies and Ironmongers. But the money deck can only get 1 province per turn, so it should lose to the engine.</p>

</details>

<h3 id="game-2">Game 2</h3>

<p><img src="/img/2019/dominion-tournament-round2/kingdom2.png" alt="Kingdom 2" style="width: 80%" title="Kingdom 2" /></p>

<details>
<summary>Spoiler:</summary>

<p>Most valuable card(s): Remodel, Lackeys, and Market Square.</p>

<p>The speed of a deck based almost entirely around these three cards really surprised me. I was able to pile the provinces on T13 and didn't run out of villagers.</p>

<p>So what's the thought process here? We know there are no villages other than Lackeys, so we can't hope to build an engine that lasts for more than a couple of turns. We also know that the only trashing is from Remodel, which looks very strong -- remodeling Estates is good as always, and here we can also remodel Copper to Lackeys.</p>

<p>The next thing we notice is that Market Square combos well with Remodel for two reasons: first, Remodel activates Market Square to give us Golds, and second, Remodel loves Gold because it can be turned into Province to score a lot of points quickly.</p>

<p>I ended up spamming a *lot* of Lackeys. On most boards, that doesn't really work; you go through villagers and quickly run out of steam. Here, we can remodel some Lackeys into more Remodels instead of playing them, so that we have 3-5 Remodels in deck. In the process we get a bunch of golds with Market Square. Finally, we can empty the provinces by remodeling Gold into Province and/or Province into Province several times over a few turns.</p>

<p>Cobbler is also good; it can gain any of the key deck pieces. I opened with it on 5/2.</p>

</details>

<h3 id="game-3">Game 3</h3>

<p><img src="/img/2019/dominion-tournament-round2/kingdom3.png" alt="Kingdom 3" style="width: 80%" title="Kingdom 3" /></p>

<details>
<summary>Spoiler:</summary>

<p>Most valuable card(s): Candlestick Maker and Conquest. Honorable Mention: Legionary and Cursed Village.</p>

<p>What I learned on this board is that Conquest loves coffers. What is normally a pretty weak alt-VP card becomes very strong if you can stockpile coffers, and then spend them all on a big turn (in my case, spending 30 coins for 5 conquests, which is 2 + 4 + 6 + 8 + 10 = 30VP). I think you should be able to ignore Province entirely -- I made the mistake of buying a few Provinces before Conquesting, which caused me to almost lose.</p>

<p>Thought process: Legionary is a strong attack, which means the Engine is probably favored if it manages to play Legionary every turn. Therefore we want to build an engine, but we see that the only +actions is from Cursed Village, and there aren't any good cantrips. That means the engine has to play with Cursed Village, so it's basically a draw-to-X deck. Hireling doesn't really help at all in such a deck, but Candlestick maker works very well, as does trashing with Raze and playing 1-2 Legionaries for economy. Also, we can use Gear to accelerate hitting price points early on, and later to set aside cards in order for Cursed Village to draw.</p>

<p>Such a deck wouldn't normally be very good, because Candlestick Maker is just not a lot of economy. But if this deck is not mirrored, you can get the entire stack of Candlestick Makers and then stockpile coffers into an arbitrarily large Conquest turn. Plus Legionary every turn really slows your opponent down. FWIW, this game lasted 23 turns, which is quite long, and that was with me making the mistake of getting a few Provinces. (The reason you don't want Provinces as the engine player is that it makes the game end faster -- and the longer the game goes on, the bigger your eventual Conquest turn.)</p>

</details>

<h3 id="game-4">Game 4</h3>

<p><img src="/img/2019/dominion-tournament-round2/kingdom4.png" alt="Kingdom 4" style="width: 80%" title="Kingdom 4" /></p>

<details>
<summary>Spoiler:</summary>

<p>Most valuable card(s): City Quarter and Storeroom.</p>

<p>City Quarter combos well with any discard-for-benefit card -- e.g. Artificer, Vault, and Storeroom. (Incidentally, another discard-for-benefit card is present here, Mill. But it doesn't combo nearly as well as these other cards.) The idea is that you discard half of your hand, leaving only actions, then play CQ to draw everything up again, and repeat. The City Quarter/Storeroom deck scales economy a lot faster than e.g. just playing with City Quarter, Wharf, and Gold.</p>

<p>Wharf is also great, because it sets up the start of turn for City Quarter (to make sure we don't dud). Hideout and Lookout are both good trashers; I'm not sure which is better, but I think you get two total. Finally, Dismantle (targetting Gold) is a good gainer; I used it to gain Wharves.</p>

</details>
</div>

		<!-- <div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.8&appId=340544043003976";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

        
          <h4>Comments</h4>

          <div class="fb-comments" data-href="http://cdstanford.github.io/2019/10/01/dominion-tournament-round2/" data-colorscheme="light" data-num-posts="5" data-width="706"></div>
         -->

	</article>

	<article>

        <header>
            <h2><a href="/2019/05/12/medical-data/">Big Data Health Monitoring Should Be Mainstream Already</a></h2>
            <span class="date"><i class="icon-clock"></i><time datetime="2019-05-12">May 12, 2019</time></span><br/>
            <!-- <span class="category"><i class="icon-tag"></i> </span><br/> -->
            <!-- <span class="author"><i class="icon-user"></i> Caleb Stanford</span><br/> --> <!-- Uncomment if I ever decide I want categories -->
			<!-- Tags -->
			<span class="tags"><i class="icon-tag"></i>
				
				<a href="/tags/big-data">big-data</a> <!-- no # in the link for now -->
				<!-- <a href="tags/#big-data">big-data</a> --> <!-- getting this to work would be most ideal -->
				
				<a href="/tags/health">health</a> <!-- no # in the link for now -->
				<!-- <a href="tags/#health">health</a> --> <!-- getting this to work would be most ideal -->
				
			</span>
			<!-- Facebook comments count. -->
			<!-- Being stupid. Disabling for now. -->
			<!-- <div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.8&appId=340544043003976";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

			<span class="comments"><i class="icon-comment"></i>  Comments:
		 	<a href="http://cdstanford.github.io/2019/05/12/medical-data/"><span class="fb-comments-count" data-href=http://cdstanford.github.io/2019/05/12/medical-data/>0</span></a></span> -->

        </header>

		<div class="entry"><p>The healthcare system in the US is often rightfully criticized for the cost to patients: insurance costs, “out-of-network” costs, and so on. But in my own interactions with healthcare over the last year or two, I’ve been equally frustrated by something else: medical data is not being sufficiently gathered and utilized. In the age of big data, medicine seems to be many years behind:</p>

<ol>
  <li>
    <p>A large amount of medical data is generated in current healthcare routine, but outside of scientific studies it is only utilized on a per-patient basis.</p>
  </li>
  <li>
    <p>An even larger amount of medical data could be easily gathered, through patient-recorded logs and wearable monitoring devices, but is not being gathered or utilized.</p>
  </li>
</ol>

<p>This is sad to me, because if we’ve learned anything in the last 10 years, it’s that data is extremely valuable when used in aggregate, at maximum scale, to update models and make predictions. In particular, we are probably missing out on more sophisticated, more accurate, and more proactive health monitoring.</p>

<p>I’m not suggesting that computers should replace humans as doctors; at least, not anytime soon. Although algorithms can analyze data faster and at a larger scale than humans, they probably can’t replace doctor expertise in the short term, especially with interactive tasks (like deciding what questions to ask in response to patient symptoms, or determining what data would be most valuable to collect).</p>

<p>What I am suggesting is that we: (1) gather more data, (2) make inferences at a larger scale from a larger amount of data, that can be applied in a more individualized fashion. It was encouraging to read that <a href="https://onezero.medium.com/meet-the-worlds-most-bio-tracked-man-2077758cf5a2">at least one researcher is taking this approach</a>.</p>

<h3 id="can-you-be-more-specific-about-medical-data">Can you be more specific about “medical data”?</h3>

<p>Medical data points are taken constantly, even under the current system. If you go in for a doctor visit, several data points are gathered: the problem or symptoms you have (or lack thereof), as well as basic vital signs (pulse, blood pressure) and sometimes blood tests, urine tests, etc. Additionally, many people take data measurements at home, e.g. fitness trackers, sleep trackers, and blood pressure measurements; and people often notice symptoms and record them (e.g. stomach ache today, chest pain or back pain, feeling lousy in general, etc.). Many people would also be happy to record and track more data. I personally keep a log of minor health problems — just in case some pattern emerges, I suppose.</p>

<h3 id="how-is-the-way-we-currently-use-medical-data-insufficient">How is the way we currently use medical data insufficient?</h3>

<p>It seems to me that current medical data is not used in aggregate to update medical models and improve future predictions. In fact, my doctors have not looked at my individual data points at all. Instead, you go in for a sick visit and they listen briefly to your array of symptoms, or you go in to get help with a specific thing like sleep, or you go in for a yearly checkup and they review any problems or questions you have. Then, the doctor (a human) makes a prediction or diagnosis about a specific issue, but does not compare with your past data in aggregate and has often forgotten about other minor or major problems you may have experienced. Additionally, many minor issues are ignored if they cannot be easily diagnosed. Finally, doctors do not apply the information about your case to future cases; thus, revision to standard practices only happens over a longer period of time through medical research and controlled studies.</p>

<p>The result of this <em>limited</em> use of health data is that while doctors are good at diagnosing specific sicknesses and medical problems, they are not good at overall monitoring “healthy” individuals to make sure they continue to stay healthy, without risk for future problems. Such monitoring would require a much more subtle understanding of our medical data; an understanding that is evidently not possible using the current approach.</p>

<h3 id="but-is-there-any-guarantee-that-more-aggressive-data-mining-would-be-successful-would-models-and-predictions-actually-improve">But is there any guarantee that more aggressive data mining would be successful? Would models and predictions actually improve?</h3>

<p>No strict guarantee, no. But from my perspective there is good reason to believe the answer to the second question is “yes”; all the recent breakthroughs in big data and machine learning have shown that with enough data and computational resources, it’s usually possible to outperform humans on concrete tasks (e.g. predicting future data from past data). These methods are only continuing to improve and be applied to various domains, not just computer science problems. So I am confident that machine learning algorithms will get better, and there is no reason that that will not extend to medical diagnosis and monitoring. However, there is one important precondition, and that is that machine learning algorithms require a lot of data to perform well.</p>

<p>Right now, no one has access to that kind of data. But the data exists and much of it is already collected, or else easy to collect. Perhaps in the near future, we can utilize it?</p>

</div>

		<!-- <div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.8&appId=340544043003976";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

        
          <h4>Comments</h4>

          <div class="fb-comments" data-href="http://cdstanford.github.io/2019/05/12/medical-data/" data-colorscheme="light" data-num-posts="5" data-width="706"></div>
         -->

	</article>

	<article>

        <header>
            <h2><a href="/2019/01/30/provablep-vs-provablenp/">ProvableP vs ProvableNP</a></h2>
            <span class="date"><i class="icon-clock"></i><time datetime="2019-01-30">Jan 30, 2019</time></span><br/>
            <!-- <span class="category"><i class="icon-tag"></i> </span><br/> -->
            <!-- <span class="author"><i class="icon-user"></i> Caleb Stanford</span><br/> --> <!-- Uncomment if I ever decide I want categories -->
			<!-- Tags -->
			<span class="tags"><i class="icon-tag"></i>
				
				<a href="/tags/math">math</a> <!-- no # in the link for now -->
				<!-- <a href="tags/#math">math</a> --> <!-- getting this to work would be most ideal -->
				
				<a href="/tags/logic">logic</a> <!-- no # in the link for now -->
				<!-- <a href="tags/#logic">logic</a> --> <!-- getting this to work would be most ideal -->
				
				<a href="/tags/theory-of-computation">theory-of-computation</a> <!-- no # in the link for now -->
				<!-- <a href="tags/#theory-of-computation">theory-of-computation</a> --> <!-- getting this to work would be most ideal -->
				
			</span>
			<!-- Facebook comments count. -->
			<!-- Being stupid. Disabling for now. -->
			<!-- <div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.8&appId=340544043003976";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

			<span class="comments"><i class="icon-comment"></i>  Comments:
		 	<a href="http://cdstanford.github.io/2019/01/30/provablep-vs-provablenp/"><span class="fb-comments-count" data-href=http://cdstanford.github.io/2019/01/30/provablep-vs-provablenp/>0</span></a></span> -->

        </header>

		<div class="entry"><h3 id="introduction-and-background">Introduction and Background</h3>

<p>The <script type="math/tex">\mathsf{P}</script> versus <script type="math/tex">\mathsf{NP}</script> question asks: is it possible to determine whether a Boolean formula is satisfiable, in time polynomial in the length of the formula? Determining whether a Boolean formulas is satisfiable is called the <em>SAT problem,</em> and programs which solve the problem are called <em>SAT solvers</em>. SAT solvers are used in many modern programming tools (usually, for automatically solving some system of constraints), so the SAT problem is of great practical importance today. And it is often suggested that a solution to “<script type="math/tex">\mathsf{P}</script> versus <script type="math/tex">\mathsf{NP}</script>” would resolve whether there exists any efficient algorithm at all for SAT.</p>

<p>There are a number of reasons why this suggestion could be wrong, or at least, a number of ways to argue against it. But here’s a particular thought: what if <script type="math/tex">\mathsf{P} = \mathsf{NP}</script> (that is, SAT can be solved in polynomial time), but the polynomial-time algorithm is beyond our ability to find – and in particular, beyond our ability to prove correct? What if there <em>exists</em> some magic algorithm that happens to work, but there <em>doesn’t exist any proof</em> that it works? Or perhaps there doesn’t exist any proof that it runs in polynomial time? Such a scenario would be an unsatisfying resolution to <script type="math/tex">\mathsf{P}</script> versus <script type="math/tex">\mathsf{NP}</script>, in a way: because practically speaking, we generally only trust algorithms that we can prove correct.</p>

<p>The question I’m trying to motivate is: does <script type="math/tex">\mathsf{ProvableP} = \mathsf{ProvableNP}</script>? That is, what happens if we restrict our attention to algorithms which can be proven correct? Is this question answerable, or is it just as hard as <script type="math/tex">\mathsf{P}</script> versus <script type="math/tex">\mathsf{NP}</script>?</p>

<h3 id="summary">Summary</h3>

<p>It turns out that <script type="math/tex">\mathsf{P} = \mathsf{NP}</script> if and only if <script type="math/tex">\mathsf{ProvableP} = \mathsf{ProvableNP}</script>.
I’ll define what I mean by <script type="math/tex">\mathsf{ProvableP}</script> and <script type="math/tex">\mathsf{ProvableNP}</script>.
This post is adapted from a <a href="https://cs.stackexchange.com/q/93885/24088">question</a> and <a href="https://cs.stackexchange.com/a/95470/24088">answer</a> I made on Computer Science StackExchange.</p>

<h3 id="the-provablep-versus-provablenp-question">The ProvableP versus ProvableNP question</h3>

<p>Fix a logic <script type="math/tex">\mathcal{L}</script> that is strong enough to encode statements about Turing machines. By this I mean the same requirements as Godel’s second incompleteness theorem; but for the purposes of this question, just assume the following:</p>

<ul>
  <li>
    <p><script type="math/tex">\mathcal{L}</script> is consistent (it doesn’t prove False); and</p>
  </li>
  <li>
    <p><script type="math/tex">\mathcal{L}</script> implies the Peano arithmetic axioms of <script type="math/tex">\mathbb{N}</script> (PA).</p>
  </li>
</ul>

<p>Then define</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}
\mathsf{ProvableP} &:= \{A \mid \mathcal{L} \text{ proves } [A \in P]\} \\
\mathsf{ProvableNP} &:= \{A \mid \mathcal{L} \text{ proves } [A \in NP] \}
\end{align*} %]]></script>

<p>There’s an issue with this definition: how do we encode languages <script type="math/tex">A</script> (of which there are uncountably many) as finite objects in order for the logic <script type="math/tex">\mathcal{L}</script> to have something to say about them? In particular, how do we encode formulas for <script type="math/tex">[A \in \mathsf{P}]</script> and <script type="math/tex">[A \in \mathsf{NP}]</script>? Let us assume that languages are subsets of the natural numbers <script type="math/tex">\mathbb{N}</script>, and that any <script type="math/tex">A</script> in <script type="math/tex">\mathsf{ProvableP}</script> or <script type="math/tex">\mathsf{ProvableNP}</script> must be given by an arbitrary formula of the symbols of <script type="math/tex">\mathcal{L}</script>, i.e. it is any <em>definable</em> subset of <script type="math/tex">\mathbb{N}</script>.</p>

<p>From the definition we have that <script type="math/tex">\mathsf{ProvableP} \subseteq \mathsf{ProvableNP} \subseteq \mathsf{NP}</script>. But does <script type="math/tex">\mathsf{ProvableP} = \mathsf{ProvableNP}</script>? How does this relate to the original <script type="math/tex">\mathsf{P}</script> vs <script type="math/tex">\mathsf{NP}</script> question?</p>

<h3 id="the-answer">The Answer</h3>

<p>Obligatory warning: to my knowledge, this proof has not been rigorously checked by someone else :)
But we now argue that</p>

<script type="math/tex; mode=display">\boxed{\mathsf{ProvableP} = \mathsf{ProvableNP}
\;\;\text{ if and only if }\;\;\mathsf{P} = \mathsf{NP}.}</script>

<p>For the forward direction, assume <script type="math/tex">\mathsf{ProvableP} = \mathsf{ProvableNP}</script>, and consider any language <script type="math/tex">A</script> in <script type="math/tex">\mathsf{NP}</script>. Note that <script type="math/tex">A</script> is accepted by a nondeterministic Turing machine <script type="math/tex">N</script>, such that there exists a polynomial <script type="math/tex">p(n)</script> which bounds the longest execution branch of <script type="math/tex">N</script> on input a string of length <script type="math/tex">n</script>. Then let <script type="math/tex">N'</script> be a nondeterministic Turing machine with the following description: first, count the input length <script type="math/tex">n</script>; second, calculate <script type="math/tex">p(n)</script>; and finally, runs <script type="math/tex">N</script> for at most <script type="math/tex">p(n)</script> steps nondeterministically. If <script type="math/tex">N</script> doesn’t halt (this never actually occurs, but <script type="math/tex">N'</script> doesn’t know that for sure), <script type="math/tex">N'</script> rejects.</p>

<p>Now observe that <script type="math/tex">\mathcal{L}</script> (more specifically, PA) proves that <script type="math/tex">N'</script> runs in time <script type="math/tex">p(n)</script>. Moreover, <script type="math/tex">\mathcal{L}</script> can describe “the language of strings accepted by <script type="math/tex">N'</script>” by a formula (roughly, “there exists an sequence of configurations such that the sequence is a run of <script type="math/tex">N'</script> and ends in an accept state”). Then we have that <script type="math/tex">\mathcal{L}</script> proves <script type="math/tex">[L(N') \in \mathsf{NP}]</script>. Therefore, <script type="math/tex">L(N') \in \mathsf{ProvableNP}</script>. But we know (even if <script type="math/tex">\mathcal{L}</script> doesn’t) that <script type="math/tex">L(N') = L(N) = A</script> by construction. So <script type="math/tex">A \in \mathsf{ProvableNP}</script>. But <script type="math/tex">\mathsf{ProvableNP} = \mathsf{ProvableP} \subseteq \mathsf{P}</script>, so <script type="math/tex">A \in \mathsf{P}</script>.</p>

<p>The backward direction is a similar trick. Assume <script type="math/tex">\mathsf{P} = \mathsf{NP}</script> and that <script type="math/tex">A \in \mathsf{ProvableNP}</script>. Then <script type="math/tex">\mathsf{ProvableNP} \subseteq \mathsf{NP} = \mathsf{P}</script>, so <script type="math/tex">A \in \mathsf{P}</script>. From here, we know there is some Turing machine <script type="math/tex">M</script> and polynomial <script type="math/tex">p(n)</script> such that <script type="math/tex">M</script> runs in time <script type="math/tex">p(n)</script> and <script type="math/tex">L(M) = A</script>. Let <script type="math/tex">M'</script> be a deterministic Turing machine which, on input of length <script type="math/tex">n</script>, first calculates <script type="math/tex">p(n)</script>, and then runs <script type="math/tex">M</script> for at most <script type="math/tex">p(n)</script> steps. If <script type="math/tex">M</script> doesn’t halt, <script type="math/tex">M'</script> returns a default value, say <script type="math/tex">0</script>.</p>

<p>Then similarly to before, <script type="math/tex">\mathcal{L}</script> proves that <script type="math/tex">M'</script> halts in time <script type="math/tex">p(n)</script> and therefore that <script type="math/tex">[L(M') \in \mathsf{P}]</script>. it follows that <script type="math/tex">L(M') \in \mathsf{ProvableP}</script>, but we know (even if <script type="math/tex">\mathcal{L}</script> doesn’t) that <script type="math/tex">L(M') = L(M) = A</script>. Thus, <script type="math/tex">\mathsf{ProvableNP} = \mathsf{ProvableP}</script>. <script type="math/tex">\quad \square</script></p>

</div>

		<!-- <div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.8&appId=340544043003976";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

        
          <h4>Comments</h4>

          <div class="fb-comments" data-href="http://cdstanford.github.io/2019/01/30/provablep-vs-provablenp/" data-colorscheme="light" data-num-posts="5" data-width="706"></div>
         -->

	</article>


<!-- Paginator navigation links -->
<div id="paginator">
	
        
				<span class="prevlink">
                <a href="/">
                &laquo; Newer Posts </a>
				</span>
        
    
	
			<span class="nextlink"> <!-- "next" span class makes it flush right. -->
            <a href="/page3">
            Older Posts &raquo;</a>
			</span>
    
</div>


        </main>

        <footer>
            <hr />
            <!-- <p>Caleb Stanford, <time>2017</time>.</p> -->
        </footer>

        <script src="/scripts.js"></script>
    </body>

</html>
